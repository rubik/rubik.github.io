<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=apple-touch-icon sizes=180x180 href=/static/icons/apple-touch-icon.png><link rel=icon type=image/png href=/static/icons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/static/icons/favicon-16x16.png sizes=16x16><link rel=manifest href=/static/icons/manifest.json><link rel=mask-icon href=/static/icons/safari-pinned-tab.svg color=#2ae2b1><link rel="shortcut icon" href=/static/icons/favicon.ico><meta name=msapplication-config content="/static/icons/browserconfig.xml"><meta name=theme-color content="#ffffff"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400&display=swap" rel=stylesheet><link rel=stylesheet href=https://signal-to-noise.xyz/scss/main.min.6d905468f4703eed3a6be770925feacadfbddf831f38d2d000062749b1b4e74a.css integrity="sha256-bZBUaPRwPu06a+dwkl/qyt+934MfONLQAAYnSbG050o="><script async src=https://rum.cronitor.io/script.js></script><script>window.cronitor=window.cronitor||function(){(window.cronitor.q=window.cronitor.q||[]).push(arguments)},cronitor("config",{clientKey:"ab51f29e7df6ffe65a02338fc78976e1"})</script><title>A complete Kubernetes tutorial, part I: the basic concepts</title>
<meta name=description content="A complete Kubernetes tutorial series covering all the basics."><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/signal-to-noise.xyz\/post\/kubernetes-tutorial\/"},"headline":"A complete Kubernetes tutorial, part I: the basic concepts","name":"A complete Kubernetes tutorial, part I: the basic concepts","datePublished":"2019-11-11","dateModified":"20191111-00:00:00.000","author":{"@type":"Person","name":"Michele Lacchia"},"publisher":{"@type":"Organization","name":"Signal to Noise","logo":{"@type":"ImageObject","url":"https:\/\/signal-to-noise.xyz\/static\/images\/signal-to-noise.png"}},"description":"A complete Kubernetes tutorial series covering all the basics.","keywords":"kubernetes,containers"}</script></head><body><div class=container><header role=banner><div class=header-logo><a href=/><img src=/static/images/signal-to-noise.png width=60 height=60 alt="Signal to Noise"></a></div></header><main role=main><article class=main-content><div class=post-meta><h1>A complete Kubernetes tutorial, part I: the basic concepts</h1><span><time datetime=2019-11-11>November 11, 2019</time>, Michele Lacchia</span></div><div class=post-tags><a href=https://signal-to-noise.xyz//tags/kubernetes>kubernetes</a>
<a href=https://signal-to-noise.xyz//tags/containers>containers</a></div><h2 id=preface>Preface</h2><p>The goal of this tutorial series is to allow the reader to start deploying on
Kubernetes with a basic understanding of Kubernetes architectural principles.
We assume zero previous knowledge about Kubernetes, the only prerequisite being
a knowledge of what containers are and how they work. I recommend that you read
the sections in the order they are presented, because some sections build on
concepts explained in the previous ones. This tutorial is not short, but it
should give you a solid understanding to start deploying working applications
on Kubernetes.</p><p>This tutorial series is essentially what I would have wanted to read when I
first approached Kubernetes, instead of searching and reading lots of different
sources. It is complete in the sense that covers all the basics. More advanced
topics like RBAC, custom resource definitions, operators, etc. are not
discussed. This series is not meant to sell you Kubernetes: we will not compare
it to the alternatives or dive deeply into its benefits. However, if you are
curious and want to start deploying and orchestrating containers with
Kubernetes, this series is for you. The first part will only cover some theory,
and then we&rsquo;ll dive into a practical example. This is the structure of the
series:</p><ul><li>Part I: Kubernetes basic concepts (this post)</li><li>Part II: <a href=/post/kubernetes-tutorial-ii-deploying-an-app/>A practical and realistic example</a></li><li>Part III: <a href=/post/kubernetes-tutorial-iii-best-practices/>Best practices</a></li></ul><h4 id=table-of-contents>Table of contents</h4><ul><li><a href=#introduction>Introduction</a></li><li><a href=#pods>Pods</a></li><li><a href=#controller-objects>Controller objects</a></li><li><a href=#services>Services</a></li><li><a href=#ingresses>Ingresses</a></li><li><a href=#volumes>Volumes</a></li><li><a href=#recap>Recap</a></li><li><a href=#conclusion>Conclusion</a></li></ul><h2 id=introduction>Introduction</h2><p><a href=https://kubernetes.io/ target=_blank rel="noopener noreferrer">Kubernetes</a>, which translates from Grek to &ldquo;pilot&rdquo; or
&ldquo;helmsman&rdquo;, is an open-source system for automating deployment, scaling, and
managing containerized applications. It was born out of the necessity to
automate the deployment and management of containers across all stages of the
development cycle. Kubernetes is supported by the CNCF, a foundation created by
Google and others to house Kubernetes and other open-source computing projects.</p><p>A Kubernetes cluster consists of at least one master and multiple compute
nodes. The master is responsible for exposing the application program interface
(API), scheduling the deployments and managing the overall cluster. Each node
runs a container runtime, like Docker, and an agent that communicates with the
master (kubelet). Nodes expose compute, networking and storage resources to
applications. They can be virtual machines (VMs) running in a cloud or bare
metal servers running within a data center.</p><p>To learn how Kubernetes works, there are two related concepts you need to
understand:</p><ul><li>Kubernetes implements an <strong>object model</strong>: everything Kubernetes manages is
represented by an object, and you can view and change these objects'
attributes and state;</li><li>The second is the principle of <strong>declarative management</strong>. You can declare
the state you want your cluster to be in through manifest files, and
Kubernetes will work to bring that state into being and to preserve it. This
is why Kubernetes is often described as a desired-state manager.</li></ul><p>An object is created by supplying Kubernetes with an object “spec”. With this
spec, you define the desired state of the object by providing the
characteristics that you want.</p><p>The <strong>control plane</strong> is a term that collectively refers to the system
processes that collaborate to make a Kubernetes cluster work. They constantly
monitor the state of the cluster, and whenever the current state does not match
the desired state, remediation actions are applied. These can include
scheduling or unscheduling workloads, for example.</p><figure><img width=623 src=/static/images/kubernetes-Architecture.png alt="Architecture of a Kubernetes cluster"><figcaption><strong>Fig. 1</strong>&emsp;A client, like kubectl, interacts with the
Kubernetes API. The master node takes care of managing pods on the worker
nodes. Each of these nodes runs the kubelet agent, which communicates with
the master, and a container runtime to execute the containers.</figcaption></figure><h2 id=pods>Pods</h2><p>Each object is of a certain kind. The basic kind is <strong>Pod</strong>, which represents
the smallest deployable unit within Kubernetes. This is often a source of
confusion for beginners, who often expect to hear that the smallest Kubernetes
object is the container. That&rsquo;s not the case, because containers need an
environment that can execute them. A Pod embodies such an environment, and it
can accommodate one or more containers. If there is more than one container in
a Pod, they are tightly coupled and share resources including networking and
storage.</p><p>Kubernetes assigns each Pod a unique IP address. Every container within a Pod
shares the network namespace including the IP address and network ports.
Containers within the same Pod can communicate through localhost. A Pod can
also mount a set of volumes that are shared among its containers.</p><p>Objects are defined in YAML manifest files. As an example, this is a minimal
YAML manifest with the spec for a Pod that runs
<a href=https://hub.docker.com/_/nginx target=_blank rel="noopener noreferrer">nginx</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx:1.17.5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span></code></pre></div><p>Manifest files have certain required fields. The field <code>apiVersion</code> specifies
which API version is used to create the object; the Kubernetes API is
versioned, and this helps to maintain backward compatibility. This file
declares an object of Pod kind, which can be found in version v1. The spec
block defines the container, which in this case is built from the nginx image
and exposes port 80.</p><p>When the above manifest is deployed (we’ll see how in <a href=/post/kubernetes-tutorial-ii-deploying-an-app/>part
II</a> of this series), the
control plane determines that the desired state differs from the current state
and schedules a Pod with a container running nginx on port 80 on an available
node.</p><p><a href=https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/ target=_blank rel="noopener noreferrer">Documentation</a></p><h2 id=controller-objects>Controller objects</h2><p>Pods don&rsquo;t heal or repair themselves and they&rsquo;re not meant to run forever. They
are designed to be ephemeral and disposable. For these reasons, Pods are rarely
deployed directly. There are better ways to manage your workloads, especially
if you need to deploy multiple copies of the same Pod: instead of using
multiple manifest files that define the same Pod object, one can make use of
the so-called controller objects. One of the most commonly used ones is the
Deployment object.</p><p>A <strong>Deployment</strong> ensures that a defined set of Pods is running at any given
time. Within its object specs, you specify how many replica Pods you want, how
Pods should run, which containers should run within these Pods, and which
volume should be mounted. Based on these templates, controllers maintain the
Pods desired state within a cluster. Under the hood, a Deployment manages a
lower-level controller object, called ReplicaSet, which ensures that multiple
replicas of a Pod, all identical to one another, are running at the same time.
This allows Deployments to perform a rolling upgrade of the Pods it manages. To
perform the upgrade, the Deployment object will create a second ReplicaSet
object, and then increase the number of (upgraded) Pods in the second
ReplicaSet while it decreases the number in the first ReplicaSet.</p><p>This is how a Deployment manifest file looks like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx-proxy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>replicas</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>matchLabels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx-proxy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>template</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx-proxy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx-proxy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx:1.17.5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span></code></pre></div><p>With this manifest, the nginx-proxy Deployment is created with three replicated
Pods. the Pod template defines some metadata and the spec of each of the Pods
in this replica set. In this example, each Pod encapsulates one container that
is built from the nginx:1.17.5 image, exposing port 80. In this the Deployment,
each Pod and each container all have the same name “nginx-proxy”, but there is
no requirement to keep the same name for all these objects. More importantly,
Pod names have to be unique, and the name provided at
<code>spec.template.metadata.labels.name</code> is the prefix of the final name, which
contains a hash identifying the Pod and the ReplicaSet it belongs to.</p><p>A Deployment is an abstraction that represents a stateless application. As
such, its Pods are indistinguishable from one another. Applications that need
to maintain state are better served by the <strong>StatefulSet</strong> controller, which is
similar to a Deployment in that multiple copies of a Pod are created from the
same container spec, but with the difference that they have a stable network
identity and persistent storage. Pods created by a StatefulSet have a
predictable name, whereas those created by a Deployment have a semi-random
name. For example, Redis and Elasticsearch clusters would be deployed using a
StatefulSet configuration.</p><p>Finally, some less used controllers that are nonetheless important:</p><ul><li><strong>DaemonSets</strong> ensure that a specific Pod is always running on all or a
subset of nodes. If new nodes are added to the cluster, this controller will
automatically schedule the Pod on those nodes with the required spec;</li><li>the <strong>Job</strong> controller schedules one or more Pod required to run a task. When
the task is completed, this controller terminates all these Pods — a common
use-case for Jobs are database migrations;</li><li>the <strong>CronJob</strong> controller acts like the Job controller, but runs according
to a time-based schedule.</li></ul><p><a href=https://kubernetes.io/docs/concepts/architecture/controller/ target=_blank rel="noopener noreferrer">Documentation</a></p><h2 id=services>Services</h2><p>Remember that Pods are created and destroyed dynamically. Although they can
communicate using their assigned Pod IP addresses, these IP addresses are
ephemeral. They&rsquo;re not guaranteed to remain constant when Pods are restarted or
when scaling up and down. A <strong>Service</strong> is a static IP address that represents
a service or a function in your infrastructure. It&rsquo;s a network abstraction for
a set of Pods that deliver that service. These Pods are selected using a label
selector. Here is an example of a Service:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>backend-app-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>ClusterIP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;80&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>backend</span><span class=w>
</span></span></span></code></pre></div><p>This Service exposes an IP, from which it forwards all traffic it receives at
port 80 to port 8080 on the Pods that have a label <code>app: backend</code>.</p><p>There are a few different types of Services, and they build on top of each
other. The default and simplest one is <strong>CusterIP</strong>, as in the example above.
This type exposes the Service on a cluster-internal IP address. This is useful
for exposing Services running inside the same cluster to each other.</p><figure><img width=452 src=/static/images/kubernetes-ClusterIP.png alt="A ClusterIP Service"><figcaption><strong>Fig. 2</strong>&emsp;A ClusterIP Service can be reached from inside the
cluster. It routes traffic to all Pods matching its label selector. In this
example, the Service matches all Pods having the label <code>app:
web</code>. The Service IP can be customized with the
<code>clusterIP</code> field.</figcaption></figure><p>The type <strong>NodePort</strong> exposes the Service on each node’s IP at a static port,
and can be used to access the Pods from outside the cluster. A ClusterIP
Service, to which the NodePort Service routes, is automatically created.</p><figure><img width=452 src=/static/images/kubernetes-NodePort.png alt="A NodePort Service"><figcaption><strong>Fig. 3</strong>&emsp;A NodePort Service exposes its Pods on each node at
a random port chosen in the range 30000-32767. This port can be customized
with the <code>nodePort</code> field. Traffic to this port is routed by
Kubernetes to the Service Pods, even if they are not on the same node that
receives the requests. Internally, the Service is also visible as a
ClusterIP service.</figcaption></figure><p>The type <strong>LoadBalancer</strong> exposes the Service externally using a cloud
provider’s load balancer, e.g. Cloud Load Balancer on GCP or Elastic Load
Balancing on AWS. Unless you run Kubernetes in a managed environment (like
GKE), you will have to set up the load balancer manually. NodePort and
ClusterIP Services, to which the external load balancer routes, are
automatically created.</p><figure><img width=482 src=/static/images/kubernetes-LoadBalancer.png alt="A NodePort Service"><figcaption><strong>Fig. 4</strong>&emsp;A LoadBalancer Service creates the corresponding
NodePort Service and provisions a cloud load balancer automatically.</figcaption></figure><p><a href=https://kubernetes.io/docs/concepts/services-networking/service/ target=_blank rel="noopener noreferrer">Documentation</a></p><h2 id=ingresses>Ingresses</h2><p>Typically, you use Services to expose your Pods inside or outside the cluster
to other components of your architecture, but you don&rsquo;t route HTTP(S) traffic
to them directly. One exception to this are cloud load balancer, which can be
configured to accept external traffic.</p><p>For HTTP(S) traffic, an <strong>Ingress</strong> offers more flexibility and features. It
can be configured to load balance traffic, do SSL/TLS termination, or to
implement name-based virtual hosting.</p><p>By itself, an Ingress only defines the configuration and has no additional
effect. To fulfill it, you also need to deploy what is called an <strong>Ingress
controller</strong>. At the time of writing, Kubernetes officially supports two:
<a href=https://github.com/kubernetes/ingress-gce/blob/master/README.md target=_blank rel="noopener noreferrer">GCE</a> and
<a href=https://github.com/kubernetes/ingress-nginx/blob/master/README.md target=_blank rel="noopener noreferrer">nginx</a>.</p><p>As an example, here is a manifest file that defines an Ingress backed by nginx:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>extensions/v1beta1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Ingress</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-ingress</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>annotations</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>kubernetes.io/ingress.class</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>tls</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>hosts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>web1.example.com</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>secretName</span><span class=p>:</span><span class=w> </span><span class=l>letsencrypt-web1-certificate-secret</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>web2.example.com</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>secretName</span><span class=p>:</span><span class=w> </span><span class=l>letsencrypt-web2-certificate-secret</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>rules</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>host</span><span class=p>:</span><span class=w> </span><span class=l>web1.example.com</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>http</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>paths</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>backend</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>serviceName</span><span class=p>:</span><span class=w> </span><span class=l>web1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>servicePort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>host</span><span class=p>:</span><span class=w> </span><span class=l>web2.example.com</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>http</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>paths</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>backend</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>serviceName</span><span class=p>:</span><span class=w> </span><span class=l>web2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>servicePort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/api</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>backend</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>serviceName</span><span class=p>:</span><span class=w> </span><span class=l>web2-api</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>servicePort</span><span class=p>:</span><span class=w> </span><span class=m>3002</span><span class=w>
</span></span></span></code></pre></div><p>This manifest files defines an Ingress that serves HTTPS traffic for
web1.example.com and web2.example.com. Traffic to the former host is entirely
routed to the service <code>web1</code>, whereas traffic to web2.example.com is routed to
the services <code>web2</code> and <code>web2-api</code> depending on the path. These services don&rsquo;t
need to be exposed, and they could be simple ClusterIP Services.</p><p>The <code>tls</code> object defines the certificate secrets. You could manually provide
them to Kubernetes or use a tool like
<a href=https://docs.cert-manager.io/en/latest/ target=_blank rel="noopener noreferrer">cert-manager</a>, but that&rsquo;s outside of
the scope of this simple overview.</p><p><a href=https://kubernetes.io/docs/concepts/services-networking/ingress/ target=_blank rel="noopener noreferrer">Documentation</a></p><h2 id=volumes>Volumes</h2><p>A container application can write data to the read-write layer inside the
container, but that is ephemeral. So when the container terminates, whatever
was written will be lost. Secondly, when running multiple containers inside a
Pod, it is often needed to share files between them. A Kubernetes Volume is
another abstraction that solves these problems. A Volume is simply a directory
that is accessible to all the containers in a Pod. The requirements for a
Volume are defined through its specification. It declares how the directory is
created, what storage medium should be used, and its initial contents. However,
Pods themselves are also ephemeral. A failing node or a deleted Pod could cause
its Volumes to be deleted too. To avoid this, you can configure Volumes to use
network-based storage that is not lost when a Pod or node fails.</p><p>An <strong>emptyDir</strong> volume is first created when a Pod is assigned to a Node, and
exists as long as that Pod is running on that node. An emptyDir volume survives
container crashes, because a Pod is not deleted if one of its container
crashes. However, it is deleted if its Pod is unscheduled.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>web</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx:1.17.5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/cache</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>cache-volume</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>cache-volume</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>emptyDir</span><span class=p>:</span><span class=w> </span>{}<span class=w>
</span></span></span></code></pre></div><p>A <strong>secret</strong> Volume is used to pass sensitive information to a Pod. The secret
must exist before it can be mounted as a Volume (we’ll do this in <a href=/post/kubernetes-tutorial-ii-deploying-an-app/>part
II</a> of this series). These
Volumes are backed by tmpfs and thus their contents are never written to disk.</p><p>For example, a secret Volume could be used to pass htpasswd-hashed data to
nginx. In the following example, the data stored in the <code>HTPASSWD</code> key of the
secret named <code>htpasswd</code> is mounted at <code>/auth/htpasswd</code> as read-only:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>web</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx:1.17.5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/auth</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>htpasswd</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>readOnly</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>htpasswd</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>secret</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>secretName</span><span class=p>:</span><span class=w> </span><span class=l>htpasswd</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>items</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>key</span><span class=p>:</span><span class=w> </span><span class=l>HTPASSWD</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>htpasswd</span><span class=w>
</span></span></span></code></pre></div><p>There are also some cloud provider-specific types like
<strong>awsElasticBlockStore</strong>, <strong>azureDisk</strong>, or <strong>gcePersistentDisk</strong> that supply
persistent, network-based storage. There are limitations, as usually you can
use these only your Kubernetes cluster is running on one of these cloud
providers. Moreover, these disks must already exist before the Volume is
mounted.</p><p>As an example, after creating a GCE persistent disk with <code>gcloud</code>,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ gcloud compute disks create --size 30GB --zone<span class=o>=</span>us-east1-b static-data-disk
</span></span></code></pre></div><p>you can mount it in a Pod as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>web</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx:1.17.5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/var/www/html</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>static-data</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>static-data</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>gcePersistentDisk</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>pdName</span><span class=p>:</span><span class=w> </span><span class=l>static-data-disk</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>fsType</span><span class=p>:</span><span class=w> </span><span class=l>ext4</span><span class=w>
</span></span></span></code></pre></div><p>There are additional restrictions: the Pod must be running on a GCE VM, and
this VM needs to be in the same GCP project and zone of the persistent disk.</p><p><a href=https://kubernetes.io/docs/concepts/storage/volumes/ target=_blank rel="noopener noreferrer">Documentation</a></p><h2 id=recap>Recap</h2><ul><li>Kubernetes enforces the state you describe through manifest files;</li><li>The desired state is abstracted by <strong>objects</strong>;</li><li>Pods are managed directly by Kubernetes and they are ephemeral;</li><li>Your application will be usually deployed with a <strong>Deployment</strong> or a
<strong>StatefulSet</strong> configuration;</li><li>Networking between components is defined by Services: <strong>ClusterIP</strong> for
intra-cluster communication, <strong>NodePort</strong> and <strong>LoadBalancer</strong> if traffic
comes from outside the cluster;</li><li>HTTP(S) traffic is served through an <strong>Ingress</strong>, which only defines the
configuration; the actual work is done by an <strong>Ingress controller</strong> like GCE
or nginx.</li><li>Persistence is achieved with the <strong>Volume</strong> abstraction &ndash; there are many
different kinds depending on your use case.</li></ul><h2 id=conclusion>Conclusion</h2><p>This tutorial was meant to give the reader a basic understanding of the most
important concepts of Kubernetes. Most of these will be put into practice in
<a href=/post/kubernetes-tutorial-ii-deploying-an-app/>part II</a> of this series, where
we will deploy a very simple application backed by Redis.</p></article></main><div id=disqus_thread class=comments></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="signal-to-noise",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><footer role=contentinfo><div class=hr></div><div class=footer-links><ul><li><script>document.write("<a href='mai&#108;to&#58;&#109;ich&#101;&#108;%65l%"+"6"+"1"+"c"+"c"+"%"+"6"+"8"+"i"+"a"+"%"+"&"+"#"+"5"+"2"+";"+"0"+"%"+"6"+"&"+"#"+"5"+"5"+";"+"&"+"#"+"1"+"0"+"9"+";"+"&"+"#"+"9"+"7"+";"+"&"+"#"+"1"+"0"+"5"+";"+"l"+"%"+"&"+"#"+"5"+"0"+";"+"E"+"%"+"6"+"3"+"o"+"m"+"'"+">"+"E"+"m"+"a"+"i"+"&"+"#"+"1"+"0"+"8"+";"+"<"+"/"+"a"+">")</script></li><li><a href=https://github.com/rubik/ target=_blank rel=noopener>GitHub</a></li><li><a href=https://www.linkedin.com/in/michele-lacchia/ target=_blank rel=noopener>LinkedIn</a></li><li><a href=/page/about/>About me</a></li><li><a href=http://feeds.feedburner.com/signal-to-noise>RSS</a></li></ul></div><div class=copyright>Created by Michele Lacchia, built with Hugo</div></footer></div><script defer src=//instant.page/5.1.1 type=module integrity=sha384-MWfCL6g1OTGsbSwfuMHc8+8J2u71/LA8dzlIN3ycajckxuZZmF+DNjdm7O6H3PSq></script></body></html>